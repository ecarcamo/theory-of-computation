# Máquina de Turing que reconoce a^n b^n c^n (con n >= 1)

q_states:
  q_list:
    - 'q0' # Estado inicial
    - 'q1' # Encontré 'a', buscando 'b'
    - 'q2' # Encontré 'b', buscando 'c'
    - 'q3' # Regresando al inicio
    - 'q4' # Estado final (aceptación)
  initial: 'q0'
  final: 'q4'

alphabet:
  - a
  - b
  - c

tape_alphabet:
  - a
  - b
  - c
  - X # Marcador para 'a'
  - Y # Marcador para 'b'
  - Z # Marcador para 'c'
  - B # Símbolo Blank

delta:
  # --- Paso 1: Encontrar 'a', marcarla X, buscar 'b' ---
  # δ(q0, a) = (q1, X, R)
  - params:
      initial_state: 'q0'
      mem_cache_value:
      tape_input: a
    output:
      final_state: 'q1'
      mem_cache_value:
      tape_output: X
      tape_displacement: R

  # --- Paso 2: Buscar 'b', marcarla Y, buscar 'c' ---
  # δ(q1, a) = (q1, a, R)
  - params:
      initial_state: 'q1'
      mem_cache_value:
      tape_input: a
    output:
      final_state: 'q1'
      mem_cache_value:
      tape_output: a
      tape_displacement: R
  # δ(q1, Y) = (q1, Y, R)
  - params:
      initial_state: 'q1'
      mem_cache_value:
      tape_input: Y
    output:
      final_state: 'q1'
      mem_cache_value:
      tape_output: Y
      tape_displacement: R
  # δ(q1, b) = (q2, Y, R)
  - params:
      initial_state: 'q1'
      mem_cache_value:
      tape_input: b
    output:
      final_state: 'q2'
      mem_cache_value:
      tape_output: Y
      tape_displacement: R

  # --- Paso 3: Buscar 'c', marcarla Z, regresar ---
  # δ(q2, b) = (q2, b, R)
  - params:
      initial_state: 'q2'
      mem_cache_value:
      tape_input: b
    output:
      final_state: 'q2'
      mem_cache_value:
      tape_output: b
      tape_displacement: R
  # δ(q2, Z) = (q2, Z, R)
  - params:
      initial_state: 'q2'
      mem_cache_value:
      tape_input: Z
    output:
      final_state: 'q2'
      mem_cache_value:
      tape_output: Z
      tape_displacement: R
  # δ(q2, c) = (q3, Z, L)
  - params:
      initial_state: 'q2'
      mem_cache_value:
      tape_input: c
    output:
      final_state: 'q3'
      mem_cache_value:
      tape_output: Z
      tape_displacement: L

  # --- Paso 4: Regresar (rebobinar) al primer X ---
  # *** ESTAS SON LAS TRANSICIONES CORREGIDAS ***
  # δ(q3, a) = (q3, a, L)
  - params:
      initial_state: 'q3'
      mem_cache_value:
      tape_input: a
    output:
      final_state: 'q3'
      mem_cache_value:
      tape_output: a
      tape_displacement: L
  # δ(q3, b) = (q3, b, L)
  - params:
      initial_state: 'q3'
      mem_cache_value:
      tape_input: b
    output:
      final_state: 'q3'
      mem_cache_value:
      tape_output: b
      tape_displacement: L
  # δ(q3, Y) = (q3, Y, L)
  - params:
      initial_state: 'q3'
      mem_cache_value:
      tape_input: Y
    output:
      final_state: 'q3'
      mem_cache_value:
      tape_output: Y
      tape_displacement: L
  # δ(q3, Z) = (q3, Z, L)
  - params:
      initial_state: 'q3'
      mem_cache_value:
      tape_input: Z
    output:
      final_state: 'q3'
      mem_cache_value:
      tape_output: Z
      tape_displacement: L
  # δ(q3, X) = (q0, X, R)
  - params:
      initial_state: 'q3'
      mem_cache_value:
      tape_input: X
    output:
      final_state: 'q0'
      mem_cache_value:
      tape_output: X
      tape_displacement: R

  # --- Paso 5: Fin. Si no hay más 'a's, buscar el final ---
  # δ(q0, Y) = (q4, Y, R)
  - params:
      initial_state: 'q0'
      mem_cache_value:
      tape_input: Y
    output:
      final_state: 'q4'
      mem_cache_value:
      tape_output: Y
      tape_displacement: R
      
  # --- Paso 6: Verificación. Asegurarse de que solo queden Ys y Zs ---
  # δ(q4, Y) = (q4, Y, R)
  - params:
      initial_state: 'q4'
      mem_cache_value:
      tape_input: Y
    output:
      final_state: 'q4'
      mem_cache_value:
      tape_output: Y
      tape_displacement: R
  # δ(q4, Z) = (q4, Z, R)
  - params:
      initial_state: 'q4'
      mem_cache_value:
      tape_input: Z
    output:
      final_state: 'q4'
      mem_cache_value:
      tape_output: Z
      tape_displacement: R
  # δ(q4, B) = (q4, B, S) (Estado de aceptación)
  - params:
      initial_state: 'q4'
      mem_cache_value:
      tape_input: B
    output:
      final_state: 'q4' # Estado final
      mem_cache_value:
      tape_output: B
      tape_displacement: S # Quédate aquí

simulation_strings:
  - "aabbcc" # Aceptada
  - "abc"    # Aceptada
  - "aabcc"  # Rechazada
  - "aabbc"  # Rechazada